---
layout: default
title: Getting Started
---

 GO HERE AND FOLLOW THIS TUTORIAL: http://docs.rosjava.googlecode.com/hg/rosjava_core/html/index.html



h2. OUT OF DATE

New members are expected to complete the following tasks. Feel free to ask in a meeting about how to complete each one and why you should do it.

* Join the "BARC organisation on GitHub":https://github.com/barcuk/barc

* Create a new milestone in the issue tracker, plus issues under this milestones to reflect the following additional tasks.

* Add your name to the "About Us":about_us.html page by checking out the BARC repository and pushing back the relevant change.

* Get ROS installed and running by working through the tutorials on "ROS.org":http://ros.org, particularly aiming for the "Stage tutorial":http://www.ros.org/wiki/stage/Tutorials/SimulatingOneRobot which shows you how to run a robot in simulation.

*  Write a simple Braitenberg machine that avoids walls using a simulated robot.

*  Put this in a real robot. 



h1. Tutorial

This tutorial will take you through the steps of up a virtualized operating system for programming with ROS and writing a basic controller which moves a wheeled robot about its environment.

h2. Set up Virtualbox 

Install *Virtualbox* and the *Virtualbox extension pack*. You can download it "here":https://www.virtualbox.org/wiki/Downloads.

Next, download the Ubuntu disk image. You can get it from "Jeremiah's server":http://jeremiahvia.com/barc/Ubuntu%2010.10.vdi or from within the "school of computer science":http://www.cs.bham.ac.uk/research/projects/poplog/robot-club/Ubuntu-10.10.vdi. The second will likely be much quicker if you're in the school of computer science. The download is ~7gb, so be patient. Once that is finished, start Virtualbox and click on the *new machine* icon.

!/images/tutorials/quick_start/vb_new_machine.png(Create a new machine)!

Now, you can click through the installer. I used the name "Ubuntu 10.10", but you may use whatever you want. You may have to select the operating system manually if you use an alternative name.

When you get to the section titled "*Virtual Hard Disk*", select the use existing hard disk radio button and select the previously downloaded disk image.

!/images/tutorials/quick_start/vb_choose_vdi.png(Choose disk image)!

You're almost done now. Before you start the machine, click on the settings button next to the new machine icon. There are some settings worth changing. If you have the memory, you probably want to increase the amount of memory. For running in simulation, you need to enable the 3D acceleration of video. I usually bump the memory up to 20mb as well.

!/images/tutorials/quick_start/vb_settings.png(Virtualbox settings)!

Okay, now you're ready! Start up the virtual machine and you will be greeted with a login screen. The password is *hacker*.

!/images/tutorials/quick_start/vb_startup.png(Startup)!

Onward!

h2. Download the BARC repository

We're going to download the repository into our ROS workspace. You can find this at @~/ros_workspace@. To verify that ROS will be able to find it, let's check our @ROS_PACKAGE_PATH@. This is list of places where ROS will look for the programs we write. Open a terminal (CTRL-ALT-T shortcut) and verify this:

{% highlight console %}
hacker@barc:~$ echo $ROS_PACKAGE_PATH
/home/hacker/ros_workspace:/opt/ros/electric/stacks
{% endhighlight %}

And so there it is.

We can now move to this directory and checkout the repository. This will ask you to verify the certificate. If you select permanently, be careful about sharing your disk image with others, because your password may be stored on the system.

{% highlight console %}
hacker@barc:~$ cd ros
hacker@barc:~/ros_workspace$ svn checkout https://codex.cs.bham.ac.uk/svn/nah/robotclub/trunk barc
{% endhighlight %}

Now, let's test the system. Open another terminal and start the ROS master server:

{% highlight console %}
hacker@barc:~$ roscore
{% endhighlight %}

Back in your original terminal, you can make sure that the simulated environment works by running:

{% highlight console %}
hacker@barc:~/ros_workspace/barc$ roslaunch barc_stage pioneer_stage.launch
{% endhighlight %}

You should see the ground floor of the computer science building with a robot in the center. Play around with the views, for example turning on the data and going into perspective mode.

!/images/tutorials/quick_start/stage.png(Stage Simlator)!

Almost there!



h2. Set up rosjava

The version of rosjava in the Ubuntu repository is out of date and broken, so it have to install it from their repository. First, you have to remove the old version and then you can install the current version.

{% highlight console %}
hacker@barc:~$ sudo apt-get remove ros-electric-rosjava-core
hacker@barc:~$ cd ros/sources
hacker@barc:~/ros_workspace/sources$ hg clone https://rosjava.googlecode.com/hg/ rosjava_core
hacker@barc:~/ros_workspace/sources$ rospack profile && rosstack profile
hacker@barc:~/ros_workspace/sources$ rosmake rosjava
{% endhighlight %}

Okay, that's done now. Towards greatness!



h2. Writing your first piece of robot code h3. Create the project

Now comes time for the real fun! You're going to write a simple Braitenberg machine that avoids walls. It does this rather simply, by splitting its laser scan in half and using each half to calculate the excitation to the wheels.

{% highlight console %}
  hacker@barc:~/ros_workspace/barc/barc_stage$ cd ~/ros_workspace
  hacker@barc:~/ros_workspace$ roscreate-pkg braitenberg rosjava std_msgs sensor_msgs geometry_msgs nav_msgs
{% endhighlight %}

Now you have to edit some files for `rosjava` to work correctly.

First, change into the new Braitenberg directory and then edit the @Makefile@:

{% highlight console %}
hacker@barc:~/ros_workspace$ cd braitenberg/
hacker@barc:~/ros_workspace/braitenberg$ gedit Makefile &
{% endhighlight %}

You have to replace the line in the `Makefile` with this snippet:

@include $(shell rospack find rosjava_bootstrap)/rosjava.mk@

Now, you have to add the @build.xml@ file. You can create and open the file by doing:

{% highlight console %}
hacker@barc:~/ros_workspace/braitenberg$ touch build.xml
hacker@barc:~/ros_workspace/braitenberg$ gedit build.xml &
{% endhighlight %}

Now paste this into the file:

{% highlight xml %}
<?xml version="1.0" encoding="UTF-8"?>
<project name="." default="default">

  <property file="ros.properties" />
  <property name="build" location="build" />

  <property name="dist" location="dist" />
  <property name="build" location="build" />
  <property name="src" location="src" />

  <path id="classpath">
    <pathelement path="${ros.compile.classpath}" />
  </path>

  <echo message="${toString:classpath}" />

  <target name="default" depends="init, compile" />

  <target name="init">
    <fail unless="ros.compile.classpath" message="ros.properties is missing.  Please type 'rosmake' first "/>
    <mkdir dir="${build}" />
    <mkdir dir="${dist}" />
  </target>

  <target name="compile" depends="init">

    <javac destdir="${build}">
      <classpath refid="classpath" />
      <src path="${src}" />
    </javac>
  </target>

  <target name="clean">
    <delete dir="${build}" />
    <delete dir="${dist}" />
  </target>

  <!-- required entry point -->
  <target name="test" />

</project>
{% endhighlight %}

Okay, now you can make the package. The reason you build the package for a Java project is because @rosmake@ needs to build the jars for each message type you depend on, as listed in your @manifest.xml@ file. After the initial call to @rosmake@, you can just use @ant@ to build your project. This saves a lot of time.

{% highlight console %}
hacker@barc:~/ros_workspace/braitenberg$ rosmake
{% endhighlight %}

As part of the build process, @rosmake@ generates Eclipse project files and some other system specific files. When you start working with the repository, you'll want to make sure you set the @svn:ignore@ properties to exclude these files from being submitted.


h3. Coding the Braitenberg machine

To get started, we first have to install Netbeans (or whatever editor you prefer).

{% highlight console %}
hacker@barc:~/ros_workspace/braitenberg$ sudo apt-get install netbeans
{% endhighlight %}

Once that is installed, start Netbeans. Once Netbeans is started, navigate to @File > Import project > Eclipse project@. Choose to import the project ignoring the project dependencies. Make the input and output folders the braitenberg package.

!/images/tutorials/quick_start/netbeans_import.png(Netbeans Import)!

Create a package called @barc@. Inside the package, make a Java file named @BraitnebergMover@. Now make the class implement @NodeMain@. This is the interface that specifies node behavior and create the empty implementations of the required methods. Your class should look like this:

{% highlight java %}
package barc;

import org.ros.node.NodeConfiguration;
import org.ros.node.NodeMain;

public class BraitenbergMover implements NodeMain {

    public void main(NodeConfiguration nc) throws Exception {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void shutdown() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

}
{% endhighlight %}

Now that you have the skeleton, it's time to flesh it out a bit. First, we need some fields for the class. We need a field of type @Node@, which will be the way this class communicates to the ROS XML-RPC server. You also need to create a @Publisher@ of type @Twist@ will which publish our movement messages to subscribing nodes. The publisher will publish on the @cmd_vel@ topic, which is listened to by other noes which control the robot.

After the fields are initialized, you need to subscribe to messages published to @base_scan@ of type @LaseScan@. This is the laser data that the robot will use to guide its movement. Inside the subscriber method, make an anonymous class to call the callback method @move@.

Finally, you need to implement the @shutdown@ method. This is simply involves calling @node.shutdown()@. When you're done, the changed code should like this:

{% highlight java %}
private Node node;
private Publisher pub;

public void main(NodeConfiguration nc) throws Exception {
    node = new DefaultNodeFactory().newNode("braitenberg", nc);
    pub = node.newPublisher("cmd_vel", "geometry_msgs/Twist");

    node.newSubscriber("base_scan", "sensor_msgs/LaserScan", new MessageListener<LaserScan>() {
        @Override
        public void onNewMessage(LaserScan scan) {
            move(scan);
        }
    });
}

public void shutdown() {
    node.shutdown();
}
{% endhighlight %}

The interesting part of the code is creating the @move@ method. This is where you get to tell the robot how to move.

This is a very basic way to move the robot. Essentially, each half of the lase scan is summed into its own variable. Then the difference between these two halves is used to calculate the rotation in the z-axis. Also, a slight forward motion is always applied just to keep the robot going along. The method looks like this:

{% highlight java %}
private void move(LaserScan scan) {
        double left = 0.0, right = 0.0;

        // get space on each side
        for (int i = 0; i < scan.ranges.length; i++) {
            double range = (scan.ranges[i] == 0.0) ? scan.range_max : scan.ranges[i];
            if (i < scan.ranges.length / 2) {
                left += range;
            } else {
                right += range;
            }
        }

        // publish a twist command to move towards the area of greatest space
        Twist move = new Twist();
        move.linear.x = 0.1;
        move.angular.z = (right - left) / (scan.ranges.length) * 0.5;
        pub.publish(move);
}
{% endhighlight %}

So, in the end, your code should look like this:

{% highlight java %}
package barc;

import org.ros.internal.node.DefaultNode;
import org.ros.message.MessageListener;
import org.ros.message.geometry_msgs.Twist;
import org.ros.message.sensor_msgs.LaserScan;
import org.ros.node.DefaultNodeFactory;
import org.ros.node.Node;
import org.ros.node.NodeConfiguration;
import org.ros.node.NodeMain;
import org.ros.node.topic.Publisher;

public class BraitenbergMover implements NodeMain {

    private Node node;
    private Publisher<Twist> pub;

    public void main(NodeConfiguration nc) throws Exception {
        node = new DefaultNodeFactory().newNode("braitenberg", nc);
        pub = node.newPublisher("cmd_vel", "geometry_msgs/Twist");

        node.newSubscriber("base_scan", "sensor_msgs/LaserScan", new MessageListener<LaserScan>() {

                @Override
                    public void onNewMessage(LaserScan scan) {
                    move(scan);
                }
            });
    }

    private void move(LaserScan scan) {
        double left = 0.0, right = 0.0;

        // get space on each side
        for (int i = 0; i < scan.ranges.length; i++) {
            double range = (scan.ranges[i] == 0.0) ? scan.range_max : scan.ranges[i];
            if (i < scan.ranges.length / 2) {
                left += range;
            } else {
                right += range;
            }
        }

        // publish a twist command to move towards the area of greatest space
        Twist move = new Twist();
        move.linear.x = 0.1;
        move.angular.z = (right - left) / (scan.ranges.length) * 0.5;
        pub.publish(move);
        System.out.println("Published: " + move);
    }

    public void shutdown() {
        node.shutdown();
    }
}
{% endhighlight %}


h3. Running it

To get your code running, you will need to start @roscore@ if it's not already running and then start the simulator, both in separate terminals. Then, once that is done, you can start your program.

{% highlight console %}
hacker@barc:~$ roscore
hacker@barc:~$ roslaunch barc_stage pioneer_stage.launch 
hacker@barc:~/ros_workspace/barc/barc_stage$ roscd braitenberg/
hacker@barc:~/ros_workspace/braitenberg$ ant
hacker@barc:~/ros_workspace/braitenberg$ rosrun rosjava_bootstrap run.py braitenberg barc.BraitenbergMover
{% endhighlight %}

And with any luck, you should not see your robot moving about its environment and avoiding obstacles. You can experiment to find better ways to move!

If you have any trouble that you cannot resolve yourself (i.e., Google), please post to the "mailing list":/basics.html! There are a number of us there who can help.
